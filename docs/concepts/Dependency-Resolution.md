---
title: NuGet Paket Bağımlılık Çözümü
description: NuGet paketinin bağımlılıklarının çözülüp hem NuGet 2.x hem de NuGet 3.x+'ta yüklendiği işlemle ilgili ayrıntılar.
author: karann-msft
ms.author: karann
ms.date: 08/14/2017
ms.topic: conceptual
ms.openlocfilehash: 4b95251e4b055523a9533b4125589b2650be932d
ms.sourcegitcommit: 2b50c450cca521681a384aa466ab666679a40213
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 04/07/2020
ms.locfileid: "79428830"
---
# <a name="how-nuget-resolves-package-dependencies"></a><span data-ttu-id="a6e0d-103">NuGet paket bağımlılıklarını nasıl çözer?</span><span class="sxs-lookup"><span data-stu-id="a6e0d-103">How NuGet resolves package dependencies</span></span>

<span data-ttu-id="a6e0d-104">Bir paket yüklendiğinde veya yeniden yüklendiğinde, bu da geri [yükleme](../consume-packages/package-restore.md) işleminin bir parçası olarak yüklenmesini de içerir, NuGet ayrıca ilk paketin bağlı olduğu ek paketleri de yükler.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-104">Any time a package is installed or reinstalled, which includes being installed as part of a [restore](../consume-packages/package-restore.md) process, NuGet also installs any additional packages on which that first package depends.</span></span>

<span data-ttu-id="a6e0d-105">Bu acil bağımlılıklar daha sonra da keyfi bir derinliğe devam edebilir kendi bağımlılıkları olabilir.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-105">Those immediate dependencies might then also have dependencies on their own, which can continue to an arbitrary depth.</span></span> <span data-ttu-id="a6e0d-106">Bu, tüm düzeylerdeki paketler arasındaki ilişkileri açıklayan bağımlılık *grafiği* olarak adlandırılan bir grafik üretir.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-106">This produces what's called a *dependency graph* that describes the relationships between packages at all levels.</span></span>

<span data-ttu-id="a6e0d-107">Birden çok paket aynı bağımlılığa sahipse, aynı paket kimliği grafikte birden çok kez görünebilir ve bu da farklı sürüm kısıtlamalarıyla olabilir.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-107">When multiple packages have the same dependency, then the same package ID can appear in the graph multiple times, potentially with different version constraints.</span></span> <span data-ttu-id="a6e0d-108">Ancak, belirli bir paketin yalnızca bir sürümü projede kullanılabilir, bu nedenle NuGet hangi sürümün kullanılacağını seçmelidir.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-108">However, only one version of a given package can be used in a project, so NuGet must choose which version is used.</span></span> <span data-ttu-id="a6e0d-109">Tam işlem, kullanılan paket yönetim biçimine bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-109">The exact process depends on the package management format being used.</span></span>

## <a name="dependency-resolution-with-packagereference"></a><span data-ttu-id="a6e0d-110">PackageReference ile bağımlılık çözümü</span><span class="sxs-lookup"><span data-stu-id="a6e0d-110">Dependency resolution with PackageReference</span></span>

<span data-ttu-id="a6e0d-111">Paket Başvurusu biçimini kullanarak projelere paketleri yüklerken, NuGet uygun dosyadaki düz paket grafiğine referanslar ekler ve çakışmaları önceden giderir.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-111">When installing packages into projects using the PackageReference format, NuGet adds references to a flat package graph in the appropriate file and resolves conflicts ahead of time.</span></span> <span data-ttu-id="a6e0d-112">Bu işlem *geçişli geri yükleme*olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-112">This process is referred to as *transitive restore*.</span></span> <span data-ttu-id="a6e0d-113">Paketleri yeniden yüklemek veya geri yüklemek, grafikte listelenen paketleri indirme işlemidir ve bu da daha hızlı ve daha öngörülebilir yapılara neden olur.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-113">Reinstalling or restoring packages is then a process of downloading the packages listed in the graph, resulting in faster and more predictable builds.</span></span> <span data-ttu-id="a6e0d-114">Ayrıca, 2,8 gibi kayan sürümlerden de yararlanabilirsiniz. \*, bir paketin en son sürümünü kullanmak için projeyi değiştirmemek için.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-114">You can also take advantage of floating versions, such as 2.8.\*,  to avoid modifying the project to use the latest version of a package.</span></span>

<span data-ttu-id="a6e0d-115">NuGet geri yükleme işlemi bir yapıdan önce çalıştığında, önce bellekteki bağımlılıkları giderir, `project.assets.json`sonra ortaya çıkan grafiği adlı bir dosyaya yazar.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-115">When the NuGet restore process runs prior to a build, it resolves dependencies first in memory, then writes the resulting graph to a file called `project.assets.json`.</span></span> <span data-ttu-id="a6e0d-116">Ayrıca, kilit dosyası `packages.lock.json` [işlevselliği etkinse,](../consume-packages/package-references-in-project-files.md#locking-dependencies)çözülmüş bağımlılıkları adlı bir kilit dosyasına da yazar.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-116">It also writes the resolved dependencies to a lock file named `packages.lock.json`, if the [lock file functionality is enabled](../consume-packages/package-references-in-project-files.md#locking-dependencies).</span></span>
<span data-ttu-id="a6e0d-117">Varlıklar dosyası, projenin `MSBuildProjectExtensionsPath`'obj' klasörüne varsayılan olarak bulunan bir dosyada bulunur.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-117">The assets file is located at `MSBuildProjectExtensionsPath`, which defaults to the project's 'obj' folder.</span></span> <span data-ttu-id="a6e0d-118">MSBuild daha sonra bu dosyayı okur ve olası başvuruların bulunabileceği bir klasör kümesine çevirir ve bunları bellekteki proje ağacına ekler.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-118">MSBuild then reads this file and translates it into a set of folders where potential references can be found, and then adds them to the project tree in memory.</span></span>

<span data-ttu-id="a6e0d-119">Dosya `project.assets.json` geçicidir ve kaynak denetimine eklenmemelidir.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-119">The `project.assets.json` file is temporary and should not be added to source control.</span></span> <span data-ttu-id="a6e0d-120">Her ikisinde de `.gitignore` varsayılan `.tfignore`olarak listelenir.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-120">It's listed by default in both `.gitignore` and `.tfignore`.</span></span> <span data-ttu-id="a6e0d-121">[Bkz. Paketler ve kaynak denetimi.](../consume-packages/packages-and-source-control.md)</span><span class="sxs-lookup"><span data-stu-id="a6e0d-121">See [Packages and source control](../consume-packages/packages-and-source-control.md).</span></span>

### <a name="dependency-resolution-rules"></a><span data-ttu-id="a6e0d-122">Bağımlılık çözümleme kuralları</span><span class="sxs-lookup"><span data-stu-id="a6e0d-122">Dependency resolution rules</span></span>

<span data-ttu-id="a6e0d-123">Geçişli geri yükleme bağımlılıkları gidermek için dört ana kural uygular: en düşük geçerli sürüm, kayan sürümler, en yakın kazançlar ve kuzen bağımlılıkları.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-123">Transitive restore applies four main rules to resolve dependencies: lowest applicable version, floating versions, nearest-wins, and cousin dependencies.</span></span>

<a name="lowest-applicable-version"></a>

#### <a name="lowest-applicable-version"></a><span data-ttu-id="a6e0d-124">En düşük uygulanabilir sürüm</span><span class="sxs-lookup"><span data-stu-id="a6e0d-124">Lowest applicable version</span></span>

<span data-ttu-id="a6e0d-125">Uygulanabilir en düşük sürüm kuralı, bir paketin bağımlılıkları tarafından tanımlanan mümkün olan en düşük sürümünü geri yükler.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-125">The lowest applicable version rule restores the lowest possible version of a package as defined by its dependencies.</span></span> <span data-ttu-id="a6e0d-126">Kayan olarak beyan edilmedikçe, uygulama veya sınıf [floating](#floating-versions)kitaplığı üzerindeki bağımlılıklar için de geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-126">It also applies to dependencies on the application or the class library unless declared as [floating](#floating-versions).</span></span>

<span data-ttu-id="a6e0d-127">Aşağıdaki şekilde, örneğin, 1.0-beta 1.0'dan daha düşük kabul edilir, bu nedenle NuGet 1.0 sürümünü seçer:</span><span class="sxs-lookup"><span data-stu-id="a6e0d-127">In the following figure, for example, 1.0-beta is considered lower than 1.0 so NuGet chooses the 1.0 version:</span></span>

![En düşük geçerli sürümü seçme](media/projectJson-dependency-1.png)

<span data-ttu-id="a6e0d-129">Bir sonraki şekilde, sürüm 2.1 akışta kullanılamaz, ancak sürüm kısıtlaması >= 2.1 NuGet bulacağı bir sonraki en düşük sürümü seçtiğinden, bu durumda 2.2:</span><span class="sxs-lookup"><span data-stu-id="a6e0d-129">In the next figure, version 2.1 is not available on the feed but because the version constraint is >= 2.1 NuGet picks the next lowest version it can find, in this case 2.2:</span></span>

![Akışta kullanılabilen bir sonraki en düşük sürümü seçme](media/projectJson-dependency-2.png)

<span data-ttu-id="a6e0d-131">Bir uygulama, akışta bulunmayan 1.2 gibi tam bir sürüm numarası belirttiğinde, NuGet paketi yüklemeye veya geri yüklemeye çalışırken bir hatayla başarısız olur:</span><span class="sxs-lookup"><span data-stu-id="a6e0d-131">When an application specifies an exact version number, such as 1.2, that is not available on the feed, NuGet fails with an error when attempting to install or restore the package:</span></span>

![NuGet, tam paket sürümü kullanılamadığında bir hata oluşturur](media/projectJson-dependency-3.png)

<a name="floating-versions"></a>

#### <a name="floating-versions"></a><span data-ttu-id="a6e0d-133">Kayan sürümler</span><span class="sxs-lookup"><span data-stu-id="a6e0d-133">Floating versions</span></span>

<span data-ttu-id="a6e0d-134">\* Kayan bağımlılık sürümü karakterle birlikte belirtilir.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-134">A floating dependency version is specified with the \* character.</span></span> <span data-ttu-id="a6e0d-135">Örneğin, `6.0.*`.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-135">For example, `6.0.*`.</span></span> <span data-ttu-id="a6e0d-136">Bu sürüm belirtimi "en son 6.0.x sürümünü kullanın" diyor; `4.*` "en son 4.x sürümünü kullanın" anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-136">This version specification says "use the latest 6.0.x version"; `4.*` means "use the latest 4.x version."</span></span> <span data-ttu-id="a6e0d-137">Kayan bir sürümü kullanmak, bir bağımlılığın en son sürümüyle güncel tutarken proje dosyasındaki değişiklikleri azaltır.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-137">Using a floating version reduces changes to the project file, while keeping up to date with the latest version of a dependency.</span></span>

<span data-ttu-id="a6e0d-138">NuGet kayan bir sürümü kullanırken, sürüm deseniyle eşleşen bir paketin `6.0.*` en yüksek sürümünü çözer, örneğin 6.0 ile başlayan bir paketin en yüksek sürümünü alır:</span><span class="sxs-lookup"><span data-stu-id="a6e0d-138">When using a floating version, NuGet resolves the highest version of a package that matches the version pattern, for example `6.0.*` gets the highest version of a package that starts with 6.0:</span></span>

![Kayan bir sürüm 6.0.\* istendiğinde sürüm 6.0.1'i seçme](media/projectJson-dependency-4.png)

> [!Note]
> <span data-ttu-id="a6e0d-140">Kayan sürümlerin ve ön sürüm sürümlerinin davranışı hakkında bilgi [için](package-versioning.md#version-ranges)bkz.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-140">For information on the behavior of floating versions and pre-release versions, see [Package versioning](package-versioning.md#version-ranges).</span></span>


<a name="nearest-wins"></a>

#### <a name="nearest-wins"></a><span data-ttu-id="a6e0d-141">En yakın galibiyetler</span><span class="sxs-lookup"><span data-stu-id="a6e0d-141">Nearest wins</span></span>

<span data-ttu-id="a6e0d-142">Bir uygulamanın paket grafiği aynı paketin farklı sürümlerini içeriyorsa, NuGet grafikteki uygulamaya en yakın paketi seçer ve diğer lerini yok sayar.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-142">When the package graph for an application contains different versions of the same package, NuGet chooses the package that's closest to the application in the graph and ignores all others.</span></span> <span data-ttu-id="a6e0d-143">Bu davranış, bir uygulamabağımlılık grafiğinde belirli bir paket sürümünü geçersiz kılmak için izin verir.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-143">This behavior allows an application to override any particular package version in the dependency graph.</span></span>

<span data-ttu-id="a6e0d-144">Aşağıdaki örnekte, uygulama doğrudan >=2.0 sürüm kısıtlaması ile B Paketine bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-144">In the example below, the application depends directly on Package B with a version constraint of >=2.0.</span></span> <span data-ttu-id="a6e0d-145">Uygulama aynı zamanda A paketine de bağlıdır ve bu da B paketine bağlıdır, ancak >=1.0 kısıtlaması ile birlikte.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-145">The application also depends on Package A which in turn also depends on Package B, but with a >=1.0 constraint.</span></span> <span data-ttu-id="a6e0d-146">B 2.0 Paketine bağımlılık grafikteki uygulamaya daha yakın olduğundan, bu sürüm kullanılır:</span><span class="sxs-lookup"><span data-stu-id="a6e0d-146">Because the dependency on Package B 2.0 is nearer to the application in the graph, that version is used:</span></span>

![En Yakın Kazançlar kuralını kullanarak uygulama](media/projectJson-dependency-5.png)

>[!Warning]
> <span data-ttu-id="a6e0d-148">En Yakın Kazançlar kuralı, paket sürümünün düşmesine neden olabilir ve böylece grafikteki diğer bağımlılıkları kırabilir.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-148">The Nearest Wins rule can result in a downgrade of the package version, thus potentially breaking other dependencies in the graph.</span></span> <span data-ttu-id="a6e0d-149">Bu nedenle bu kural kullanıcıyı uyarmak için bir uyarı ile uygulanır.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-149">Hence this rule is applied with a warning to alert the user.</span></span>

<span data-ttu-id="a6e0d-150">Bu kural aynı zamanda büyük bir bağımlılık grafiğiyle (BCL paketlerindekiler gibi) daha fazla verimlilik sağlar, çünkü belirli bir bağımlılık göz ardı edildikten sonra NuGet grafiğin o dalı üzerinde kalan tüm bağımlılıkları da göz ardı eder.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-150">This rule also results in greater efficiency with a large dependency graph (such as those with the BCL packages) because once a given dependency is ignored, NuGet also ignores all remaining dependencies on that branch of the graph.</span></span> <span data-ttu-id="a6e0d-151">Aşağıdaki diyagramda, örneğin, Paket C 2.0 kullanıldığından, NuGet grafikte C Paketinin eski bir sürümüne atıfta bulunan dalları yoksa:</span><span class="sxs-lookup"><span data-stu-id="a6e0d-151">In the diagram below, for example, because Package C 2.0 is used, NuGet ignores any branches in the graph that refer to an older version of Package C:</span></span>

![NuGet grafikteki bir paketi yok saydığında, tüm dalı yoksa](media/projectJson-dependency-6.png)

<a name="cousin-dependencies"></a>

#### <a name="cousin-dependencies"></a><span data-ttu-id="a6e0d-153">Kuzen bağımlılıkları</span><span class="sxs-lookup"><span data-stu-id="a6e0d-153">Cousin dependencies</span></span>

<span data-ttu-id="a6e0d-154">Farklı paket sürümleri uygulamadan grafikte aynı mesafede atıfta bulunulduğunda, NuGet tüm sürüm gereksinimlerini karşılayan en düşük sürümü kullanır [(geçerli en düşük sürüm](#lowest-applicable-version) ve [kayan sürüm](#floating-versions) kurallarında olduğu gibi).</span><span class="sxs-lookup"><span data-stu-id="a6e0d-154">When different package versions are referred to at the same distance in the graph from the application, NuGet uses the lowest version that satisfies all version requirements (as with the [lowest applicable version](#lowest-applicable-version) and [floating versions](#floating-versions) rules).</span></span> <span data-ttu-id="a6e0d-155">Aşağıdaki resimde, örneğin, B Paketinin 2.0 sürümü diğer >=1.0 kısıtlamasını karşılar ve böylece kullanılır:</span><span class="sxs-lookup"><span data-stu-id="a6e0d-155">In the image below, for example, version 2.0 of Package B satisfies the other >=1.0 constraint, and is thus used:</span></span>

![Tüm kısıtlamaları karşılayan alt sürümü kullanarak kuzen bağımlılıklarını çözme](media/projectJson-dependency-7.png)

<span data-ttu-id="a6e0d-157">Bazı durumlarda, tüm sürüm gereksinimlerini karşılamak mümkün değildir.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-157">In some cases, it's not possible to meet all version requirements.</span></span> <span data-ttu-id="a6e0d-158">Aşağıda gösterildiği gibi, A Paketi tam olarak B 1.0 paketi gerektiriyorsa ve C Paketi B >=2.0 gerektiriyorsa, NuGet bağımlılıkları çözemez ve hata verir.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-158">As shown below, if Package A requires exactly Package B 1.0 and Package C requires Package B >=2.0, then NuGet cannot resolve the dependencies and gives an error.</span></span>

![Tam sürüm gereksinimi nedeniyle çözülemeyen bağımlılıklar](media/projectJson-dependency-8.png)

<span data-ttu-id="a6e0d-160">Bu gibi durumlarda, en [yakın kazançlar](#nearest-wins) kuralının geçerli olması için üst düzey tüketicinin (uygulama veya paket) B Paketine doğrudan bağımlılığını eklemesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-160">In these situations, the top-level consumer (the application or package) should add its own direct dependency on Package B so that the [Nearest Wins](#nearest-wins) rule applies.</span></span>

## <a name="dependency-resolution-with-packagesconfig"></a><span data-ttu-id="a6e0d-161">packages.config ile bağımlılık çözümü</span><span class="sxs-lookup"><span data-stu-id="a6e0d-161">Dependency resolution with packages.config</span></span>

<span data-ttu-id="a6e0d-162">Ile `packages.config`, bir projenin bağımlılıkları `packages.config` düz bir liste olarak yazılır.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-162">With `packages.config`, a project's dependencies are written to `packages.config` as a flat list.</span></span> <span data-ttu-id="a6e0d-163">Bu paketlerin herhangi bir bağımlılıkları da aynı listede yazılır.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-163">Any dependencies of those packages are also written in the same list.</span></span> <span data-ttu-id="a6e0d-164">Paketler yüklendiğinde, NuGet dosyayı `.csproj` `app.config` `web.config`ve diğer dosyaları da değiştirebilir.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-164">When packages are installed, NuGet might also modify the `.csproj` file, `app.config`, `web.config`, and other individual files.</span></span>

<span data-ttu-id="a6e0d-165">Ile, `packages.config`NuGet her bir paketin yüklenmesi sırasında bağımlılık çakışmaları çözmek için çalışır.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-165">With `packages.config`, NuGet attempts to resolve dependency conflicts during the installation of each individual package.</span></span> <span data-ttu-id="a6e0d-166">Diğer bir deyişle, A Paketi yüklüyse ve B Paketine bağlıysa `packages.config` ve B Paketi zaten başka bir şeyin bağımlılığı olarak listelenmişse, NuGet B Paketinin istenen sürümlerini karşılaştırır ve tüm sürüm kısıtlamalarını karşılayan bir sürüm bulmaya çalışır.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-166">That is, if Package A is being installed and depends on Package B, and Package B is already listed in `packages.config` as a dependency of something else, NuGet compares the versions of Package B being requested and attempts to find a version that satisfies all version constraints.</span></span> <span data-ttu-id="a6e0d-167">Özellikle, NuGet bağımlılıkları tatmin eden alt *majör.küçük* sürümü seçer.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-167">Specifically, NuGet selects the lower *major.minor* version that satisfies dependencies.</span></span>

<span data-ttu-id="a6e0d-168">Varsayılan olarak, NuGet 2.8 en düşük yama sürümünü arar (Bkz. [NuGet 2.8 sürüm notları).](../release-notes/nuget-2.8.md#patch-resolution-for-dependencies)</span><span class="sxs-lookup"><span data-stu-id="a6e0d-168">By default, NuGet 2.8 looks for the lowest patch version (see [NuGet 2.8 release notes](../release-notes/nuget-2.8.md#patch-resolution-for-dependencies)).</span></span> <span data-ttu-id="a6e0d-169">Bu ayarı, komut `DependencyVersion` satırındaki `Nuget.Config` öznitelik ve `-DependencyVersion` anahtar üzerinden denetleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-169">You can control this setting through the `DependencyVersion` attribute in `Nuget.Config` and the `-DependencyVersion` switch on the command line.</span></span>  

<span data-ttu-id="a6e0d-170">Bağımlılıkları `packages.config` çözme işlemi, daha büyük bağımlılık grafikleri için karmaşık hale getirir.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-170">The `packages.config` process for resolving dependencies gets complicated for larger dependency graphs.</span></span> <span data-ttu-id="a6e0d-171">Her yeni paket yüklemesi tüm grafiğin bir geçiş gerektirir ve sürüm çakışmaları için şansı yükseltir.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-171">Each new package installation requires a traversal of the whole graph and raises the chance for version conflicts.</span></span> <span data-ttu-id="a6e0d-172">Bir çakışma oluştuğunda, yükleme durdurulur ve proje belirsiz bir durumda bırakılır, özellikle proje dosyasının kendisinde olası değişiklikler yapılır.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-172">When a conflict occurs, installation is stopped, leaving the project in an indeterminate state, especially with potential modifications to the project file itself.</span></span> <span data-ttu-id="a6e0d-173">Bu, diğer paket yönetim biçimlerini kullanırken bir sorun değildir.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-173">This is not an issue when using other package management formats.</span></span>

## <a name="managing-dependency-assets"></a><span data-ttu-id="a6e0d-174">Bağımlılık varlıklarını yönetme</span><span class="sxs-lookup"><span data-stu-id="a6e0d-174">Managing dependency assets</span></span>

<span data-ttu-id="a6e0d-175">PackageReference biçimini kullanırken, bağımlılıklardan hangi varlıkların üst düzey projeye aktığını denetleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-175">When using the PackageReference format, you can control which assets from dependencies flow into the top-level project.</span></span> <span data-ttu-id="a6e0d-176">Ayrıntılar için [PackageReference'a](../consume-packages/package-references-in-project-files.md#controlling-dependency-assets)bakın.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-176">For details, see [PackageReference](../consume-packages/package-references-in-project-files.md#controlling-dependency-assets).</span></span>

<span data-ttu-id="a6e0d-177">Üst düzey projenin kendisi bir paket olduğunda, `include` `exclude` `.nuspec` dosyada listelenen bağımlılıkları olan ve öznitelikleri ni ve özniteliklerini kullanarak bu akış üzerinde denetime de sahip olursunuz.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-177">When the top-level project is itself a package, you also have control over this flow by using the `include` and `exclude` attributes with dependencies listed in the `.nuspec` file.</span></span> <span data-ttu-id="a6e0d-178">[Bkz..nuspec Başvuru - Bağımlılıklar](../reference/nuspec.md#dependencies).</span><span class="sxs-lookup"><span data-stu-id="a6e0d-178">See [.nuspec Reference - Dependencies](../reference/nuspec.md#dependencies).</span></span>

## <a name="excluding-references"></a><span data-ttu-id="a6e0d-179">Referansları hariç alma</span><span class="sxs-lookup"><span data-stu-id="a6e0d-179">Excluding references</span></span>

<span data-ttu-id="a6e0d-180">Aynı ada sahip derlemelerin projede birden fazla kez başvurulabileceği ve tasarım zamanı ve yapı zamanı hataları üreten senaryolar vardır.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-180">There are scenarios in which assemblies with the same name might be referenced more than once in a project, producing design-time and build-time errors.</span></span> <span data-ttu-id="a6e0d-181">Özel bir sürümünü `C.dll`içeren bir proje düşünün ve Aynı `C.dll`zamanda içeren Paket C'ye başvurur.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-181">Consider a project that contains a custom version of `C.dll`, and references Package C that also contains `C.dll`.</span></span> <span data-ttu-id="a6e0d-182">Aynı zamanda proje aynı zamanda C paketine ve `C.dll`B Paketine de bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-182">At the same time, the project also depends on Package B which also depends on Package C and `C.dll`.</span></span> <span data-ttu-id="a6e0d-183">Sonuç olarak, NuGet hangisini `C.dll` kullanacağınızı belirleyemez, ancak B Paketi de buna bağlı olduğundan projenin C Paketine olan bağımlılığını kaldıramaz.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-183">As a result, NuGet can't determine which `C.dll` to use, but you can't just remove the project's dependency on Package C because Package B also depends on it.</span></span>

<span data-ttu-id="a6e0d-184">Bunu çözmek için, doğrudan `C.dll` istediğiniz başvuru (veya doğru bir başvuru başka bir paket kullanın) ve sonra tüm varlıklarını hariç C Paketi bir bağımlılık eklemeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-184">To resolve this, you must directly reference the `C.dll` you want (or use another package that references the right one), and then add a dependency on Package C that excludes all its assets.</span></span> <span data-ttu-id="a6e0d-185">Bu, kullanımdaki paket yönetim biçimine bağlı olarak aşağıdaki gibi yapılır:</span><span class="sxs-lookup"><span data-stu-id="a6e0d-185">This is done as follows depending on the package management format in use:</span></span>

- <span data-ttu-id="a6e0d-186">[PackageReference](../consume-packages/package-references-in-project-files.md): `ExcludeAssets="All"` bağımlılık ekleyin:</span><span class="sxs-lookup"><span data-stu-id="a6e0d-186">[PackageReference](../consume-packages/package-references-in-project-files.md): add `ExcludeAssets="All"` in the dependency:</span></span>

    ```xml
    <PackageReference Include="PackageC" Version="1.0.0" ExcludeAssets="All" />
    ```

- <span data-ttu-id="a6e0d-187">`packages.config`: Yalnızca istediğiniz sürümüreferans `.csproj` `C.dll` böylece dosyadan PackageC için başvuru kaldırın.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-187">`packages.config`: remove the reference to PackageC from the `.csproj` file so that it references only the version of `C.dll` that you want.</span></span>
    
## <a name="dependency-updates-during-package-install"></a><span data-ttu-id="a6e0d-188">Paket yükleme sırasında bağımlılık güncelleştirmeleri</span><span class="sxs-lookup"><span data-stu-id="a6e0d-188">Dependency updates during package install</span></span> 

<span data-ttu-id="a6e0d-189">Bağımlılık sürümü zaten memnunsa, bağımlılık diğer paket yüklemeleri sırasında güncelleştirilemiyor.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-189">If a dependency version is already satisfied, the dependency isn't updated during other package installations.</span></span> <span data-ttu-id="a6e0d-190">Örneğin, B paketine bağlı olan ve sürüm numarası için 1.0'ı belirten A paketini düşünün.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-190">For example, consider package A that depends on package B and specifies 1.0 for the version number.</span></span> <span data-ttu-id="a6e0d-191">Kaynak deposu, B paketinin 1.0, 1.1 ve 1.2 sürümlerini içerir. A zaten B sürüm 1.0 içeren bir projede yüklüyse, sürüm kısıtlamasını karşıladığı için B 1.0 kullanılmaya devam eder.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-191">The source repository contains versions 1.0, 1.1, and 1.2 of package B. If A is installed in a project that already contains B version 1.0, then B 1.0 remains in use because it satisfies the version constraint.</span></span> <span data-ttu-id="a6e0d-192">Ancak, A paketi sürüm 1.1 veya b'nin daha yüksek isteklerini varsa, B 1.2 yüklenirdi.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-192">However, if package A had requests version 1.1 or higher of B, then B 1.2 would be installed.</span></span> 

## <a name="resolving-incompatible-package-errors"></a><span data-ttu-id="a6e0d-193">Uyumsuz paket hatalarını çözme</span><span class="sxs-lookup"><span data-stu-id="a6e0d-193">Resolving incompatible package errors</span></span>

<span data-ttu-id="a6e0d-194">Paket geri yükleme işlemi sırasında "Bir veya daha fazla paket uyumlu değil..." hatasını görebilirsiniz. veya bir paketin projenin hedef çerçevesi ile "uyumlu olmadığını" belirtin.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-194">During a package restore operation, you may see the error "One or more packages are not compatible..." or that a package "is not compatible" with the project's target framework.</span></span>

<span data-ttu-id="a6e0d-195">Bu hata, projenizde başvurulan paketlerden birinin veya birkaçının projenin hedef çerçevesini desteklediğini göstermemesi durumunda oluşur; diğer bir deyişle, `lib` paket, projeyle uyumlu bir hedef çerçeve için klasöründe uygun bir DLL içermez.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-195">This error occurs when one or more of the packages referenced in your project do not indicate that they support the project's target framework; that is, the package does not contain a suitable DLL in its `lib` folder for a target framework that is compatible with the project.</span></span> <span data-ttu-id="a6e0d-196">(Bir liste için [Hedef çerçevelerine](../reference/target-frameworks.md) bakın.)</span><span class="sxs-lookup"><span data-stu-id="a6e0d-196">(See [Target frameworks](../reference/target-frameworks.md) for a list.)</span></span> 

<span data-ttu-id="a6e0d-197">Örneğin, bir proje `netstandard1.6` hedefliyorsa ve yalnızca klasörlerde `lib\net20` ve `\lib\net45` klasörlerde DL içeren bir paket yüklemeye çalışırsanız, paket ve muhtemelen bağımlıları için aşağıdaki gibi iletileri görürsünüz:</span><span class="sxs-lookup"><span data-stu-id="a6e0d-197">For example, if a project targets `netstandard1.6` and you attempt to install a package that contains DLLs in only the `lib\net20` and `\lib\net45` folders, then you see messages like the following for the package and possibly its dependents:</span></span>

```output
Restoring packages for myproject.csproj...
Package ContosoUtilities 2.1.2.3 is not compatible with netstandard1.6 (.NETStandard,Version=v1.6). Package ContosoUtilities 2.1.2.3 supports:
  - net20 (.NETFramework,Version=v2.0)
  - net45 (.NETFramework,Version=v4.5)
Package ContosoCore 0.86.0 is not compatible with netstandard1.6 (.NETStandard,Version=v1.6). Package ContosoCore 0.86.0 supports:
  - 11 (11,Version=v0.0)
  - net20 (.NETFramework,Version=v2.0)
  - sl3 (Silverlight,Version=v3.0)
  - sl4 (Silverlight,Version=v4.0)
One or more packages are incompatible with .NETStandard,Version=v1.6.
Package restore failed. Rolling back package changes for 'MyProject'.
```

<span data-ttu-id="a6e0d-198">Uyumsuzlukları gidermek için aşağıdakilerden birini yapın:</span><span class="sxs-lookup"><span data-stu-id="a6e0d-198">To resolve incompatibilities, do one of the following:</span></span>

- <span data-ttu-id="a6e0d-199">Projenizi kullanmak istediğiniz paketler tarafından desteklenen bir çerçeveye yeniden hedefleyin.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-199">Retarget your project to a framework that is supported by the packages you want to use.</span></span>
- <span data-ttu-id="a6e0d-200">Paketlerin yazarıyla iletişime geçin ve seçtiğiniz çerçeveye destek eklemek için onlarla birlikte çalışın.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-200">Contact the author of the packages and work with them to add support for your chosen framework.</span></span> <span data-ttu-id="a6e0d-201">[nuget.org'daki](https://www.nuget.org/) her paket listeleme sayfasının bu amaçla bir **İletişim Sahipleri** bağlantısı vardır.</span><span class="sxs-lookup"><span data-stu-id="a6e0d-201">Each package listing page on [nuget.org](https://www.nuget.org/) has a **Contact Owners** link for this purpose.</span></span>
